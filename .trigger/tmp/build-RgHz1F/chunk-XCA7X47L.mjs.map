{
  "version": 3,
  "sources": ["../../../src/trigger/media.ts"],
  "sourcesContent": ["import { task } from \"@trigger.dev/sdk/v3\";\nimport { exec } from \"child_process\";\nimport { promisify } from \"util\";\nimport * as fs from \"fs\";\nimport * as path from \"path\";\nimport * as os from \"os\";\n\nconst execAsync = promisify(exec);\n\n/**\n * Media Task Contract:\n * Job ID: media-process\n * Payload: { operation, inputUrl, params }\n * Output: { url: string }\n */\n\ntype MediaPayload = {\n    operation: \"CROP\" | \"EXTRACT_FRAME\";\n    inputUrl: string;\n    params: {\n        x?: number;\n        y?: number;\n        width?: number;\n        height?: number;\n        timestamp?: number | string; // e.g., 5 or \"50%\"\n    };\n};\n\ntype MediaOutput = {\n    url: string;\n    localPath?: string; // For debugging\n};\n\n// Helper to download file from URL\nasync function downloadFile(url: string, outputPath: string): Promise<void> {\n    const response = await fetch(url);\n    if (!response.ok) {\n        throw new Error(`Failed to download: ${response.status}`);\n    }\n    const buffer = await response.arrayBuffer();\n    fs.writeFileSync(outputPath, Buffer.from(buffer));\n}\n\n// Helper to parse timestamp (supports \"50%\" or number of seconds)\nfunction parseTimestamp(timestamp: number | string | undefined, duration?: number): string {\n    if (timestamp === undefined) return \"0\";\n\n    if (typeof timestamp === \"string\" && timestamp.endsWith(\"%\")) {\n        const percent = parseFloat(timestamp.replace(\"%\", \"\"));\n        if (duration) {\n            return String((percent / 100) * duration);\n        }\n        // If no duration, return 0 for percentage\n        return \"0\";\n    }\n\n    return String(timestamp);\n}\n\n// Helper to get video duration using ffprobe\nasync function getVideoDuration(inputPath: string): Promise<number> {\n    try {\n        const { stdout } = await execAsync(\n            `ffprobe -v error -show_entries format=duration -of default=noprint_wrappers=1:nokey=1 \"${inputPath}\"`\n        );\n        return parseFloat(stdout.trim());\n    } catch {\n        return 0;\n    }\n}\n\n// Helper to upload to Transloadit (simplified - in production use proper SDK)\nasync function uploadToTransloadit(filePath: string): Promise<string> {\n    // For MVP, we'll store files locally and return a local path\n    // In production, you'd upload to Transloadit/S3 and get a public URL\n\n    const authKey = process.env.NEXT_PUBLIC_TRANSLOADIT_AUTH_KEY;\n    const authSecret = process.env.TRANSLOADIT_AUTH_SECRET;\n\n    if (!authKey || !authSecret) {\n        // Return local file path if Transloadit not configured\n        console.log(\"Transloadit not configured, using local path\");\n        return `file://${filePath}`;\n    }\n\n    // TODO: Implement actual Transloadit upload\n    // For now, return the local path\n    return `file://${filePath}`;\n}\n\nexport const mediaProcessTask = task({\n    id: \"media-process\",\n    maxDuration: 180, // 3 minutes max for media processing\n    run: async (payload: MediaPayload): Promise<MediaOutput> => {\n        const { operation, inputUrl, params } = payload;\n\n        // Create temp directory for processing\n        const tempDir = fs.mkdtempSync(path.join(os.tmpdir(), \"media-\"));\n        const inputExt = path.extname(new URL(inputUrl).pathname) || \".mp4\";\n        const inputPath = path.join(tempDir, `input${inputExt}`);\n        const outputPath = path.join(tempDir, \"output.jpg\");\n\n        try {\n            // Download the input file\n            console.log(`Downloading from: ${inputUrl}`);\n            await downloadFile(inputUrl, inputPath);\n            console.log(`Downloaded to: ${inputPath}`);\n\n            let ffmpegCommand: string;\n\n            if (operation === \"EXTRACT_FRAME\") {\n                // Get video duration for percentage-based timestamps\n                const duration = await getVideoDuration(inputPath);\n                const timestampSeconds = parseTimestamp(params.timestamp, duration);\n\n                // FFmpeg command: extract single frame at timestamp\n                ffmpegCommand = `ffmpeg -ss ${timestampSeconds} -i \"${inputPath}\" -frames:v 1 -y \"${outputPath}\"`;\n                console.log(`Extracting frame at ${timestampSeconds}s`);\n\n            } else if (operation === \"CROP\") {\n                const { x = 0, y = 0, width = 100, height = 100 } = params;\n\n                // For percentage-based crop, we need to calculate actual pixels\n                // This simplified version assumes percentage values (0-100)\n                // FFmpeg crop filter: crop=out_w:out_h:x:y\n                // Using iw/ih (input width/height) for percentage calculations\n                const cropFilter = `crop=iw*${width}/100:ih*${height}/100:iw*${x}/100:ih*${y}/100`;\n\n                ffmpegCommand = `ffmpeg -i \"${inputPath}\" -filter:v \"${cropFilter}\" -frames:v 1 -y \"${outputPath}\"`;\n                console.log(`Cropping with filter: ${cropFilter}`);\n\n            } else {\n                throw new Error(`Unknown operation: ${operation}`);\n            }\n\n            // Execute FFmpeg\n            console.log(`Running: ${ffmpegCommand}`);\n            const { stdout, stderr } = await execAsync(ffmpegCommand);\n\n            if (stderr) {\n                console.log(\"FFmpeg stderr:\", stderr);\n            }\n\n            // Verify output exists\n            if (!fs.existsSync(outputPath)) {\n                throw new Error(\"FFmpeg did not produce output file\");\n            }\n\n            // Upload the result\n            const outputUrl = await uploadToTransloadit(outputPath);\n\n            return {\n                url: outputUrl,\n                localPath: outputPath,\n            };\n\n        } catch (error) {\n            // Cleanup on error\n            try {\n                fs.rmSync(tempDir, { recursive: true, force: true });\n            } catch { }\n            throw error;\n        }\n    },\n});\n\n// Convenience tasks for specific operations\nexport const cropImageTask = task({\n    id: \"crop-image\",\n    maxDuration: 120,\n    run: async (payload: { inputUrl: string; x: number; y: number; width: number; height: number }) => {\n        return mediaProcessTask.triggerAndWait({\n            operation: \"CROP\",\n            inputUrl: payload.inputUrl,\n            params: {\n                x: payload.x,\n                y: payload.y,\n                width: payload.width,\n                height: payload.height,\n            },\n        });\n    },\n});\n\nexport const extractFrameTask = task({\n    id: \"extract-frame\",\n    maxDuration: 120,\n    run: async (payload: { inputUrl: string; timestamp: number | string }) => {\n        return mediaProcessTask.triggerAndWait({\n            operation: \"EXTRACT_FRAME\",\n            inputUrl: payload.inputUrl,\n            params: {\n                timestamp: payload.timestamp,\n            },\n        });\n    },\n});\n"],
  "mappings": "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",
  "names": []
}
