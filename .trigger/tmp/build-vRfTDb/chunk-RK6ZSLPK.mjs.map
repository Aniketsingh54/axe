{
  "version": 3,
  "sources": ["../../../src/trigger/media.ts"],
  "sourcesContent": ["import { task } from \"@trigger.dev/sdk/v3\";\nimport { exec } from \"child_process\";\nimport { promisify } from \"util\";\nimport * as fs from \"fs\";\nimport * as path from \"path\";\nimport * as os from \"os\";\n\nconst execAsync = promisify(exec);\n\n/**\n * Media Task Contract:\n * Job ID: media-process\n * Payload: { operation, inputUrl, params }\n * Output: { url: string }\n */\n\ntype MediaPayload = {\n    operation: \"CROP\" | \"EXTRACT_FRAME\";\n    inputUrl: string;\n    params: {\n        x?: number;\n        y?: number;\n        width?: number;\n        height?: number;\n        timestamp?: number | string; // e.g., 5 or \"50%\"\n    };\n};\n\ntype MediaOutput = {\n    url: string;\n    localPath?: string; // For debugging\n};\n\n// Helper to download file from URL\nasync function downloadFile(url: string, outputPath: string): Promise<void> {\n    const response = await fetch(url);\n    if (!response.ok) {\n        throw new Error(`Failed to download: ${response.status}`);\n    }\n    const buffer = await response.arrayBuffer();\n    fs.writeFileSync(outputPath, Buffer.from(buffer));\n}\n\n// Helper to parse timestamp (supports \"50%\" or number of seconds)\nfunction parseTimestamp(timestamp: number | string | undefined, duration?: number): string {\n    if (timestamp === undefined) return \"0\";\n\n    if (typeof timestamp === \"string\" && timestamp.endsWith(\"%\")) {\n        const percent = parseFloat(timestamp.replace(\"%\", \"\"));\n        if (duration) {\n            return String((percent / 100) * duration);\n        }\n        // If no duration, return 0 for percentage\n        return \"0\";\n    }\n\n    return String(timestamp);\n}\n\n// Helper to get video duration using ffprobe\nasync function getVideoDuration(inputPath: string): Promise<number> {\n    try {\n        const { stdout } = await execAsync(\n            `ffprobe -v error -show_entries format=duration -of default=noprint_wrappers=1:nokey=1 \"${inputPath}\"`\n        );\n        return parseFloat(stdout.trim());\n    } catch (error) {\n        console.warn(\"Failed to get video duration:\", error);\n        return 0;\n    }\n}\n\n// Helper to upload to Transloadit (simplified - in production use proper SDK)\nasync function uploadToTransloadit(filePath: string): Promise<string> {\n    const authKey = process.env.NEXT_PUBLIC_TRANSLOADIT_AUTH_KEY;\n    const isPlaceholder = authKey === \"c767882fc1143c30a6480eda2e2a6921\";\n\n    if (!authKey || isPlaceholder) {\n        console.log(\"Transloadit AUTH KEY not configured or placeholder, using base64 fallback\");\n        const buffer = fs.readFileSync(filePath);\n        return `data:image/jpeg;base64,${buffer.toString('base64')}`;\n    }\n\n    try {\n        console.log(`Uploading ${filePath} to Transloadit...`);\n        const fileBuffer = fs.readFileSync(filePath);\n        const fileName = path.basename(filePath);\n\n        // Create FormData\n        const formData = new FormData();\n        const blob = new Blob([fileBuffer]);\n        formData.append(\"file\", blob, fileName);\n\n        // Params\n        const params = {\n            auth: { key: authKey },\n            steps: {\n                \":original\": { robot: \"/upload/handle\" },\n                optimized: { robot: \"/image/optimize\", use: \":original\", progressive: true }\n            }\n        };\n\n        formData.append(\"params\", JSON.stringify(params));\n\n        const response = await fetch(\"https://api2.transloadit.com/assemblies\", {\n            method: \"POST\",\n            body: formData,\n        });\n\n        if (!response.ok) {\n            throw new Error(`Upload failed: ${response.status} ${response.statusText}`);\n        }\n\n        const result: any = await response.json();\n\n        if (result.error) {\n            throw new Error(result.error);\n        }\n\n        console.log(`Assembly created: ${result.assembly_id}, polling for completion...`);\n\n        // Poll for completion with exponential backoff\n        const assemblyUrl = result.assembly_url;\n\n        let attempts = 0;\n        let delay = 500; // Start at 500ms\n        const maxDelay = 3000; // Max 3 seconds between polls\n        const maxAttempts = 30; // ~30 seconds total max\n\n        while (attempts < maxAttempts) {\n            const statusRes = await fetch(assemblyUrl);\n            const status: any = await statusRes.json();\n\n            if (status.ok === \"ASSEMBLY_COMPLETED\") {\n                const results = status.results.optimized || status.results[\":original\"];\n                if (results && results.length > 0) {\n                    const url = results[0].ssl_url || results[0].url;\n                    console.log(`Upload complete after ${attempts + 1} attempts: ${url}`);\n                    return url;\n                }\n            }\n\n            if (status.error) {\n                throw new Error(status.error);\n            }\n\n            console.log(`Polling attempt ${attempts + 1}/${maxAttempts}, waiting ${delay}ms...`);\n            await new Promise(r => setTimeout(r, delay));\n            delay = Math.min(delay * 1.5, maxDelay); // Exponential backoff\n            attempts++;\n        }\n\n        throw new Error(\"Transloadit upload timed out after 30 attempts\");\n\n    } catch (error) {\n        console.error(\"Transloadit upload error, falling back to base64:\", error);\n        const buffer = fs.readFileSync(filePath);\n        return `data:image/jpeg;base64,${buffer.toString('base64')}`;\n    }\n}\n\nexport const mediaProcessTask = task({\n    id: \"media-process\",\n    maxDuration: 180, // 3 minutes max for media processing\n    run: async (payload: MediaPayload): Promise<MediaOutput> => {\n        const { operation, inputUrl, params } = payload;\n\n        // Create temp directory for processing\n        const tempDir = fs.mkdtempSync(path.join(os.tmpdir(), \"media-\"));\n        const inputExt = path.extname(new URL(inputUrl).pathname) || \".mp4\";\n        const inputPath = path.join(tempDir, `input${inputExt}`);\n        const outputPath = path.join(tempDir, \"output.jpg\");\n\n        try {\n            // Download the input file\n            console.log(`Downloading from: ${inputUrl}`);\n            await downloadFile(inputUrl, inputPath);\n            console.log(`Downloaded to: ${inputPath}`);\n\n            let ffmpegCommand: string;\n\n            if (operation === \"EXTRACT_FRAME\") {\n                // Get video duration for percentage-based timestamps\n                const duration = await getVideoDuration(inputPath);\n                const timestampSeconds = parseTimestamp(params.timestamp, duration);\n\n                // FFmpeg command: extract single frame at timestamp\n                ffmpegCommand = `ffmpeg -ss ${timestampSeconds} -i \"${inputPath}\" -frames:v 1 -y \"${outputPath}\"`;\n                console.log(`Extracting frame at ${timestampSeconds}s`);\n\n            } else if (operation === \"CROP\") {\n                const { x = 0, y = 0, width = 100, height = 100 } = params;\n\n                // For percentage-based crop, we need to calculate actual pixels\n                // This simplified version assumes percentage values (0-100)\n                // FFmpeg crop filter: crop=out_w:out_h:x:y\n                // Using iw/ih (input width/height) for percentage calculations\n                const cropFilter = `crop=iw*${width}/100:ih*${height}/100:iw*${x}/100:ih*${y}/100`;\n\n                ffmpegCommand = `ffmpeg -i \"${inputPath}\" -filter:v \"${cropFilter}\" -frames:v 1 -y \"${outputPath}\"`;\n                console.log(`Cropping with filter: ${cropFilter}`);\n\n            } else {\n                throw new Error(`Unknown operation: ${operation}`);\n            }\n\n            // Execute FFmpeg\n            console.log(`Running: ${ffmpegCommand}`);\n            const { stdout, stderr } = await execAsync(ffmpegCommand);\n\n            if (stderr) {\n                console.log(\"FFmpeg stderr:\", stderr);\n            }\n\n            // Verify output exists\n            if (!fs.existsSync(outputPath)) {\n                throw new Error(\"FFmpeg did not produce output file\");\n            }\n\n            // Upload the result\n            const outputUrl = await uploadToTransloadit(outputPath);\n\n            return {\n                url: outputUrl,\n                localPath: outputPath,\n            };\n\n        } catch (error) {\n            // Cleanup on error\n            try {\n                fs.rmSync(tempDir, { recursive: true, force: true });\n            } catch { }\n            throw error;\n        }\n    },\n});\n\n// Convenience tasks for specific operations\nexport const cropImageTask = task({\n    id: \"crop-image\",\n    maxDuration: 120,\n    run: async (payload: { inputUrl: string; x: number; y: number; width: number; height: number }) => {\n        return mediaProcessTask.triggerAndWait({\n            operation: \"CROP\",\n            inputUrl: payload.inputUrl,\n            params: {\n                x: payload.x,\n                y: payload.y,\n                width: payload.width,\n                height: payload.height,\n            },\n        });\n    },\n});\n\nexport const extractFrameTask = task({\n    id: \"extract-frame\",\n    maxDuration: 120,\n    run: async (payload: { inputUrl: string; timestamp: number | string }) => {\n        return mediaProcessTask.triggerAndWait({\n            operation: \"EXTRACT_FRAME\",\n            inputUrl: payload.inputUrl,\n            params: {\n                timestamp: payload.timestamp,\n            },\n        });\n    },\n});\n"],
  "mappings": "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",
  "names": []
}
